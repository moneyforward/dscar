version: 2.1

description: |
  Delta Static Code Analysis Reports running on CircleCI

  This Orb calculates the difference between two static code analysis results. However, the format of the static code analysis result must be JUnit XML.
  Using this Orb, you can get the static code analysis result for the update difference between HEAD branch and its BASE branch.
orbs:
  compare-url: iynere/compare-url@1.2.0
  node: circleci/node@1.1.6
executors:
  default:
    description: Use a CircleCI convenience image to analyze code statically
    docker:
    - image: circleci/node:lts
commands:
  analyze:
    description: Analyze code statically
    parameters:
      command:
        description: The command used for analysis
        type: string
        default: "true"
      arguments:
        description: Arguments of analysis command
        type: string
        default: ""
      results-path:
        description: Path to save analysis results
        type: string
        default: "/dev/null"
      ignore-exit-code:
        description: Specify true if you want the exit code of the analysis step to always return 0.
        type: boolean
        default: true
      prepare:
        description: Specify the required steps before analysis if necessary
        type: steps
        default: []
      step-name:
        description: Specify a analysis step name for this command, if desired
        type: string
        default: Analyze code statically
    steps:
      - steps: << parameters.prepare >>
      - run:
          name: << parameters.step-name >>
          command: |
              << parameters.command >> << parameters.arguments >> > << parameters.results-path >> || << parameters.ignore-exit-code >>
  calculate:
    description: Calculate the difference between the analysis results
    parameters:
      options:
        description: Specify options for the junit-reports-combiner command
        type: string
        default: ""
      first-results-path:
        description: Path of the file to use as the minuend
        type: string
        default: "HEAD-analysis-results.xml"
      second-results-path:
        description: Path of the file to use as the subtrahend
        type: string
        default: "BASE-analysis-results.xml"
      delta-results-path:
        description: Path to save difference of analysis results
        type: string
        default: "/dev/null"
    steps:
      - node/install
      - run:
          name: Calculate the difference
          command: |
              sudo apt-get install xmlstarlet
              sudo npm install --global junit-reports-combiner
              test `junit-reports-combiner --operator=except << parameters.options >> << parameters.first-results-path >> << parameters.second-results-path >> | tee << parameters.delta-results-path >> | xmlstarlet sel -t -m '//failure|//error'  -v '.' -n | wc -l` -eq 0
  execute:
    description: alculate the difference of static code analysis results between HEAD branch and BASE branch
    parameters:
      analysis-prepare:
        description: Specify the required steps before analysis if necessary
        type: steps
        default: []
      analysis-name:
        description: Analysis name
        type: string
        default: "true"
      analysis-command:
        description: The command used for analysis
        type: string
        default: "true"
      analysis-arguments:
        description: Arguments of analysis command
        type: string
        default: ""
      calculate-options:
        description: Specify options for the junit-reports-combiner command
        type: string
        default: ""
      test-results-path:
        description: Specify the value of the path parameter in the store_test_results step if you need to change it
        type: string
        default: "/tmp/test-results"
      analysis-results-path:
        description: Specify the path to save the analysis results if you need to change it
        type: string
        default: "/tmp/analysis-results"
    steps:
      - checkout
      - compare-url/reconstruct:
          project-path: $CIRCLE_WORKING_DIRECTORY
          debug: true
      - run:
          name: Setup
          command: |
              mkdir -p << parameters.analysis-results-path >>/<< parameters.analysis-name >>
              mkdir -p << parameters.test-results-path >>/<< parameters.analysis-name >>
      - steps: << parameters.analysis-prepare >>
      - analyze:
          step-name: Analyze the HEAD branch using << parameters.analysis-name >>
          command: << parameters.analysis-command >>
          arguments: << parameters.analysis-arguments >>
          prepare: []
          results-path: << parameters.analysis-results-path >>/<< parameters.analysis-name >>/HEAD-analysis-results.xml
      - compare-url/use:
          custom-logic: git checkout $(cat BASE_COMPARE_COMMIT.txt)
      - analyze:
          step-name: Analyze the BASE branch using << parameters.analysis-name >>
          command: << parameters.analysis-command >>
          arguments: << parameters.analysis-arguments >>
          prepare: []
          results-path: << parameters.analysis-results-path >>/<< parameters.analysis-name >>/BASE-analysis-results.xml
      - calculate:
          options: << parameters.calculate-options >>
          first-results-path: << parameters.analysis-results-path >>/<< parameters.analysis-name >>/HEAD-analysis-results.xml
          second-results-path: << parameters.analysis-results-path >>/<< parameters.analysis-name >>/BASE-analysis-results.xml
          delta-results-path: << parameters.test-results-path >>/<< parameters.analysis-name >>/DELTA-analysis-results.xml
      - store_test_results:
          path: << parameters.test-results-path >>
jobs:
  execute:
    description: Calculate the difference of static code analysis results between HEAD branch and BASE branch
    parameters:
      executor:
        type: executor
        default: default
      analysis-prepare:
        description: Specify the required steps before analysis if necessary
        type: steps
        default: []
      analysis-name:
        description: Analysis name
        type: string
        default: "true"
      analysis-command:
        description: The command used for analysis
        type: string
        default: "true"
      analysis-arguments:
        description: Arguments of analysis command
        type: string
        default: ""
      calculate-options:
        description: Specify options for the junit-reports-combiner command
        type: string
        default: ""
      test-results-path:
        description: Specify the value of the path parameter in the store_test_results step if you need to change it
        type: string
        default: "/tmp/test-results"
      analysis-results-path:
        description: Specify the path to save the analysis results if you need to change it
        type: string
        default: "/tmp/analysis-results"
    executor: << parameters.executor >>
    steps:
      - execute:
          analysis-prepare: << parameters.analysis-prepare >>
          analysis-name: << parameters.analysis-name >>
          analysis-command: << parameters.analysis-command >>
          analysis-arguments: << parameters.analysis-arguments >>
          calculate-options: << parameters.calculate-options >>
          test-results-path: << parameters.test-results-path >>
          analysis-results-path: << parameters.analysis-results-path >>

examples:
  dscar-brakeman:
    description: Calculate Brakeman's analysis results for update difference between HEAD branch and BASE branch
    usage:
      version: 2.1
      orbs:
        dscar: naokikimura/dscar@0.0.3
      workflows:
        analyzing-code-statically:
          jobs:
            - dscar/execute:
                analysis-name: Brakeman
                analysis-command: brakeman
                analysis-arguments: -f junit
                calculate-options: --test-case-key='concat(@classname,"#",@name,"=>",normalize-space())' --namespace='brakeman=https://brakemanscanner.org/'
    result:
      version: 2
      jobs:
        dscar/execute:
          docker:
          - image: circleci/node:lts
          steps:
          - checkout
          - run:
              command: "if [[ -z \"${CIRCLE_TOKEN}\" ]]; then\n  echo \"ERROR: Missing environment variable CIRCLE_TOKEN\" >&2\n  if [[ -n \"You have not stored a CircleCI API token. If this is a private repository, the next step will fail.\n\" ]]; then\n    echo \"You have not stored a CircleCI API token. If this is a private repository, the next step will fail.\n\" >&2\n  fi\n  \nelse\n  echo \"Yes, CIRCLE_TOKEN is defined!\"\nfi\n"
              name: Checking if $CIRCLE_TOKEN is defined...
          - run:
              command: |
                ## VARS

                # this starts as false, set to true to exit `until` loop
                FOUND_BASE_COMPARE_COMMIT=false

                # start iteration from the job before $CIRCLE_BUILD_NUM
                JOB_NUM=$(( $CIRCLE_BUILD_NUM - 1 ))

                ## UTILS

                extract_commit_from_job () {
                  # abstract this logic out, it gets reused a few times
                  # takes $1 (VCS_TYPE) & $2 (a job number)

                  curl --user $CIRCLE_TOKEN: \
                    https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$2 | \
                    grep '"vcs_revision" : ' | sed -E 's/"vcs_revision" ://' | sed -E 's/[[:punct:]]//g' | sed -E 's/ //g'
                }

                check_if_branch_is_new () {
                  # takes a single argument for VCS_TYPE
                  # functionally, 'new' means: same commit for all jobs on the branch

                  # assume this is true, set to false if proven otherwise
                  local BRANCH_IS_NEW=true

                  # grab URL endpoints for jobs on this branch
                  # transform them into single-job API endpoints
                  # output them to a file for subsequent iteration
                  curl --user $CIRCLE_TOKEN: \
                    https://circleci.com/api/v1.1/project/$1/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/tree/$CIRCLE_BRANCH?limit=100 | \
                    grep "\"build_url\" : \"http" | sed -E 's/"build_url" : //' | \
                    sed -E 's|/bb/|/api/v1.1/project/bitbucket/|' | \
                    sed -E 's|/gh/|/api/v1.1/project/github/|' | \
                    sed -E 's/"|,//g' | sed -E 's/ //g' \
                    > API_ENDPOINTS_FOR_JOBS_ON_BRANCH

                  # loop through each job to compare commit hashes
                  while read line
                  do
                    if [[ $(curl --user $CIRCLE_TOKEN: $line | grep "\"vcs_revision\" : \"$CIRCLE_SHA1\"") ]]; then
                      continue
                    else
                      BRANCH_IS_NEW=false
                      break
                    fi
                  done < API_ENDPOINTS_FOR_JOBS_ON_BRANCH

                  # clean up
                  if [[ true == false ]]; then
                    rm -f API_ENDPOINTS_FOR_JOBS_ON_BRANCH
                  fi

                  # true or false
                  echo $BRANCH_IS_NEW
                }

                ## SETUP

                # determine VCS type, so we don't worry about it later
                if [[ $(echo $CIRCLE_REPOSITORY_URL | grep github.com:$CIRCLE_PROJECT_USERNAME) ]]; then
                  VCS_TYPE=github
                else
                  VCS_TYPE=bitbucket
                fi

                # check if this is a new branch, as that informs later steps
                echo "checking if $CIRCLE_BRANCH is a new branch..."
                echo "----------------------------------------------------------------------------------------------------"
                if [[ $(check_if_branch_is_new $VCS_TYPE) == true ]]; then
                  echo "----------------------------------------------------------------------------------------------------"
                  echo "yes, $CIRCLE_BRANCH is new and $CIRCLE_SHA1 is its only commit"
                  echo "finding most recent ancestor commit from any other branch..."
                  echo "----------------------------------------------------------------------------------------------------"
                  BRANCH_IS_NEW=true
                else
                  echo "----------------------------------------------------------------------------------------------------"
                  echo "$CIRCLE_BRANCH is not a new branch, searching for its most recent previous commit..."
                  echo "----------------------------------------------------------------------------------------------------"
                  BRANCH_IS_NEW=false
                fi

                ## EXECUTION

                # manually iterate through previous jobs
                until [[ $FOUND_BASE_COMPARE_COMMIT == true ]]
                do

                  # save circle api output to a temp file for reuse
                  curl --user $CIRCLE_TOKEN: \
                    https://circleci.com/api/v1.1/project/$VCS_TYPE/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/$JOB_NUM \
                    > JOB_OUTPUT

                  # general approach:
                  # there's a couple of skip conditions to observe here—
                  # roughly in order of precedence:

                  # 1. is JOB_NUM part of the current workflow?
                  # 2. is JOB_NUM a retry of a job from the same commit?
                    # 2.5 or part of a rerun workflow from the same commit?
                  # 3. is JOB_NUM from a different branch?
                    # 3.5 unless this is a new branch—see below

                  # edge cases:
                  # 1. if $CIRCLE_SHA1 is the first commit on a new branch
                    # then we need the most recent ancestor, branch-agnostic
                    # 1.5 a new branch doesn't always mean a new commit

                  # handling condition 3 & edge case 1:
                  # check if this is a brand-new branch
                  if [[ $BRANCH_IS_NEW == true ]]; then
                    COMMIT_FROM_JOB_NUM=$(extract_commit_from_job $VCS_TYPE $JOB_NUM)

                    # we do a similar check later on, but it needs to be here too
                    # for edge case 1.5: an existing commit pushed to a new branch
                    if [[ $COMMIT_FROM_JOB_NUM == $CIRCLE_SHA1 ]]; then
                      JOB_NUM=$(( $JOB_NUM - 1 ))
                      continue
                    fi

                    cd $CIRCLE_WORKING_DIRECTORY

                    # check if commit from JOB_NUM is an ancestor of $CIRCLE_SHA1
                    git merge-base --is-ancestor $COMMIT_FROM_JOB_NUM $CIRCLE_SHA1 || { RETURN_CODE=$?; }

                    if [[ $RETURN_CODE == 1 ]]; then
                      echo "----------------------------------------------------------------------------------------------------"
                      echo "commit $COMMIT_FROM_JOB_NUM from job $JOB_NUM is not an ancestor of the current commit"
                      echo "----------------------------------------------------------------------------------------------------"
                      JOB_NUM=$(( $JOB_NUM - 1 ))
                      continue
                    elif [[ $RETURN_CODE == "" ]]; then
                      echo "----------------------------------------------------------------------------------------------------"
                      echo "commit $COMMIT_FROM_JOB_NUM from job $JOB_NUM is an ancestor of the current commit"
                      echo "----------------------------------------------------------------------------------------------------"
                      FOUND_BASE_COMPARE_COMMIT=true
                      break
                    else
                      echo "unknown return code $RETURN_CODE from git merge-base with base commit $COMMIT_FROM_JOB_NUM, from job $JOB_NUM"
                      exit 1
                    fi
                  else
                    # if not a new branch, find its most recent previous commit

                    # by now, if none of conditions 1, 2/2.5, or 3 apply, we're done:
                    # 1. make sure job isn't part of the same workflow
                    if [[ ! $(grep "\"workflow_id\" : \"$CIRCLE_WORKFLOW_ID\"" JOB_OUTPUT) && \
                      # 2. make sure job is not a retry of a previous job
                      $(grep '"retry_of" : null' JOB_OUTPUT) && \
                      # 2.5 make sure job is not from a rerun workflow (same commit)
                      ! $(grep "\"vcs_revision\" : \"$CIRCLE_SHA1\"" JOB_OUTPUT) && \
                      # make sure we are on the same branch as $CIRCLE_BRANCH
                      # (we've already ruled out that this is a brand-new branch)
                      $(grep "\"branch\" : \"$CIRCLE_BRANCH\"" JOB_OUTPUT) ]]; then

                      echo "----------------------------------------------------------------------------------------------------"
                      echo "success! job $JOB_NUM was neither part of the current workflow, part of a rerun workflow, a retry of a previous job, nor from a different branch"
                      echo "----------------------------------------------------------------------------------------------------"

                      FOUND_BASE_COMPARE_COMMIT=true
                    else
                      echo "----------------------------------------------------------------------------------------------------"
                      echo "job $JOB_NUM was part of the current workflow, part of a rerun workflow, a retry of a previous job, or from a different branch"
                      echo "----------------------------------------------------------------------------------------------------"
                      JOB_NUM=$(( $JOB_NUM - 1 ))
                      continue
                    fi
                  fi
                done

                ## CONCLUSION

                # clean up
                rm -f JOB_OUTPUT

                BASE_COMPARE_COMMIT=$(extract_commit_from_job $VCS_TYPE $JOB_NUM)

                # construct our compare URL, based on VCS type
                if [[ $(echo $VCS_TYPE | grep github) ]]; then
                  CIRCLE_COMPARE_URL="https://github.com/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}"
                else
                  CIRCLE_COMPARE_URL="https://bitbucket.org/$CIRCLE_PROJECT_USERNAME/$CIRCLE_PROJECT_REPONAME/branches/compare/${BASE_COMPARE_COMMIT:0:12}...${CIRCLE_SHA1:0:12}"
                fi

                echo "----------------------------------------------------------------------------------------------------"
                echo "base compare commit hash is:" $BASE_COMPARE_COMMIT
                echo ""
                echo $BASE_COMPARE_COMMIT > BASE_COMPARE_COMMIT.txt
                echo "this job's commit hash is:" $CIRCLE_SHA1
                echo "----------------------------------------------------------------------------------------------------"
                echo "recreated CIRCLE_COMPARE_URL:"
                echo $CIRCLE_COMPARE_URL
                echo "----------------------------------------------------------------------------------------------------"
                echo "outputting CIRCLE_COMPARE_URL to a file in your working directory, called CIRCLE_COMPARE_URL.txt"
                echo "(BASE_COMPARE_COMMIT has also been stored in your working directory as BASE_COMPARE_COMMIT.txt)"
                echo $CIRCLE_COMPARE_URL > CIRCLE_COMPARE_URL.txt
                echo "----------------------------------------------------------------------------------------------------"
                echo "next: both CIRCLE_COMPARE_URL.txt and BASE_COMPARE_COMMIT.txt will be persisted to a workspace, in case they are needed in later jobs"
              name: Reconstruct CIRCLE_COMPARE_URL
              when: always
          - persist_to_workspace:
              paths:
              - CIRCLE_COMPARE_URL.txt
              - BASE_COMPARE_COMMIT.txt
              root: .
          - run:
              name: Setup
              command: |
                mkdir -p /tmp/analysis-results/Brakeman
                mkdir -p /tmp/test-results/Brakeman
          - run:
              name: Analyze the HEAD branch using Brakeman
              command: |
                brakeman -f junit > /tmp/analysis-results/Brakeman/HEAD-analysis-results.xml || true
          - run:
              command: |
                # save value stored in file to a local env var
                CIRCLE_COMPARE_URL=$(cat CIRCLE_COMPARE_URL.txt)

                COMMIT_RANGE=$(echo $CIRCLE_COMPARE_URL | sed 's:^.*/compare/::g')

                echo "Commit range: $COMMIT_RANGE"

                git checkout $(cat BASE_COMPARE_COMMIT.txt)
              name: Evaluate/use CIRCLE_COMPARE_URL
          - run:
              name: Analyze the BASE branch using Brakeman
              command: |
                brakeman -f junit > /tmp/analysis-results/Brakeman/BASE-analysis-results.xml || true
          - run:
              command: "# PLATFORM CHECK: mac vs. alpine vs. other linux\nPLATFORM=linux\nif uname -a | grep Darwin > /dev/null 2>&1; then\n  PLATFORM=darwin\nelif cat /etc/issue | grep Alpine > /dev/null 2>&1; then\n  PLATFORM=alpine\nfi\n\n# FUNCTIONS\nget_node_version () {\n  if [[ latest == latest ]]; then\n    VERSION=$(curl --silent --show-error \\\n      --location --fail --retry 3 \\\n      https://api.github.com/repos/nodejs/node/releases/latest | \\\n      grep tag_name | cut -d '\"' -f 4 | \\\n      cut -d 'v' -f 2)\n\n    echo \"Latest version of Node.js is $VERSION\"\n  else\n    VERSION=latest\n\n    echo \"Selected version of Node.js is $VERSION\"\n  fi\n}\n\nnvm_check () {\n  if [[ ! -z \"$NVM_DIR\" ]]; then\n    echo \"nvm (Node.js version manager) is installed; removing it to manually install the specified version of Node.js\"\n\n    $SUDO rm -rf \"$NVM_DIR\"\n\n    perl -i -pe 's|export NVM_DIR=/opt/circleci/.nvm||' ~/.circlerc\n    perl -i -pe 's|source $NVM_DIR/nvm.sh||' ~/.circlerc\n\n    perl -i -pe 's|export NVM_DIR=\"/opt/circleci/.nvm\"||' ~/.bashrc\n    perl -i -pe 's|[ -s \"$NVM_DIR/nvm.sh\" ] && . \"$NVM_DIR/nvm.sh\"  # This loads nvm||' ~/.bashrc\n  fi\n}\n\ninstallation_check () {\n  if command -v node > /dev/null 2>&1; then\n    nvm_check\n\n    if node --version | grep \"$VERSION\" > /dev/null 2>&1; then\n\n      echo \"Node.js $VERSION is already installed\"\n      exit 0\n    else\n      echo \"A different version of Node.js is installed ($(node --version)); removing it\"\n\n      $SUDO rm -rf \"$(command -v node)\"\n      $SUDO rm -rf \"$(command -v node | sed -E 's|node||')/nodejs\"\n\n      $SUDO rm -rf \"$(command -v npm)\"\n\n      $SUDO rm -rf \\\n        /usr/local/lib/node_modules \\\n        /usr/local/include/node_modules \\\n        /opt/local/lib/node_modules\n\n    fi\n  fi\n}\n\n# DOWNLOAD/INSTALL LOGIC\nif [[ \"$PLATFORM\" == alpine ]]; then\n  if [[ nodejs-current == nodejs ]]; then\n    APK_REPO=main\n  elif [[ nodejs-current == nodejs-current ]]; then\n    APK_REPO=community\n  fi\n\n  VERSION=$(curl \\\n    --silent --show-error --location --fail --retry 3 \\\n    \"http://dl-cdn.alpinelinux.org/alpine/edge/$APK_REPO/x86_64/\" | \\\n    grep nodejs | grep -E -v '(dev|doc)' | \\\n    sed -E 's%<a href=\"%%' | sed -E 's%.apk\">nodejs-.*.apk</a>.*%%' | \\\n    sed -E 's/(nodejs-|nodejs-current-)//' | sed -E 's/-r0//')\n\n  echo \"Selected version of Node.js is: $VERSION (Alpine APK)\"\n\n  installation_check\n\n  # https://wiki.alpinelinux.org/wiki/Include:Upgrading_to_Edge\n\n  \n\n  if ! command -v perl > /dev/null 2>&1; then\n    apk add perl > /dev/null 2>&1\n  fi\n\n  perl -i -pe 's|v([0-9]+){0,1}(.[0-9]+){0,1}(.[0-9]+)|edge|g' \\\n    /etc/apk/repositories\n\n  \n\n  \n  apk upgrade --update-cache --available > /dev/null 2>&1\n\n  # https://wiki.alpinelinux.org/wiki/Enable_Community_Repository\n  if cat /etc/apk/repositories | grep -v community > /dev/null 2>&1; then\n    echo -e \"http://dl-cdn.alpinelinux.org/alpine/edge/community\" >> /etc/apk/repositories\n  fi\n\n  apk --no-cache add libuv > /dev/null 2>&1\n  apk --no-cache add --repository \\\n    \"http://dl-cdn.alpinelinux.org/alpine/edge/$APK_REPO\" \\\n    nodejs-current > /dev/null 2>&1\nelse\n  if [[ $EUID == 0 ]]; then export SUDO=\"\"; else export SUDO=\"sudo\"; fi\n\n  get_node_version\n  nvm_check\n  installation_check\n\n  $SUDO curl \\\n    --silent --show-error --location --fail --retry 3 \\\n    https://raw.githubusercontent.com/nodejs/node/master/README.md | \\\n    grep -E '[A-Z0-9]{40}' | \\\n    sed -E 's/gpg --keyserver pool.sks-keyservers.net --recv-keys //g' | \\\n    sed -E 's/(`|\\$ )//g' > \\\n    NODEJS_TRUSTED_RELEASE_KEYS\n\n  cat > KEYSERVERS << EOM\n  hkp://p80.pool.sks-keyservers.net:80\n  hkp://ipv4.pool.sks-keyservers.net\n  hkp://pgp.mit.edu:80\n  hkps://ha.pool.sks-keyservers.net\n  hkp://keyserver.ubuntu.com:80\nEOM\n\n  echo \"Importing Node.js trusted release keys...\"\n  # https://stackoverflow.com/a/26217767\n  while read key; do\n    for keyserver in $(cat KEYSERVERS); do\n      tempName=$(mktemp)\n      gpg --status-fd 1 \\\n        --keyserver \"$keyserver\" --keyserver-options \"timeout=1\" \\\n        --recv-keys \"$key\" 1> \"$tempName\" 2>/dev/null || true\n      if [[ $(grep \"^\\[GNUPG\\:\\] IMPORT_OK \"[[:digit:]]*\" \"$key\"$\" $tempName && \\\n        grep \"^\\[GNUPG\\:\\] IMPORT_RES 1\" $tempName) ]]; then\n        \n        break\n      else\n        continue\n      fi\n    done\n  done < NODEJS_TRUSTED_RELEASE_KEYS\n\n  $SUDO rm -f NODEJS_TRUSTED_RELEASE_KEYS KEYSERVERS\n\n  $SUDO curl -O \\\n    --silent --show-error --location --fail --retry 3 \\\n    \"https://nodejs.org/dist/v$VERSION/SHASUMS256.txt.asc\"\n\n  gpg --batch --decrypt --output SHASUMS256.txt SHASUMS256.txt.asc > /dev/null \\\n    && $SUDO rm -f SHASUMS256.txt.asc\n\n  # download/install node\n  $SUDO curl -O \\\n    --silent --show-error --location --fail --retry 3 \\\n      \"https://nodejs.org/dist/v$VERSION/node-v$VERSION-$PLATFORM-x64.tar.gz\"\n\n  # verify node tar via shasum256\n  grep \"node-v$VERSION-$PLATFORM-x64.tar.gz\" SHASUMS256.txt | sha256sum -c -\n\n  $SUDO rm -f SHASUMS256.txt\n\n  $SUDO tar -xzf \"node-v$VERSION-$PLATFORM-x64.tar.gz\" \\\n    -C /usr/local \\\n    --strip-components=1 --no-same-owner > /dev/null 2>&1\n\n  $SUDO rm -f \"node-v$VERSION-$PLATFORM-x64.tar.gz\"\n\n  if [[ ! -e /usr/local/bin/nodejs ]]; then\n    $SUDO ln -s /usr/local/bin/node /usr/local/bin/nodejs\n  fi\nfi\n\n# test/verify version\nif node --version | grep \"$VERSION\" > /dev/null; then\n  echo \"Node.js $(node --version) has been installed to $(which node)\"\nelse\n  echo \"Something went wrong; the specified version of Node.js could not be installed\"\n  exit 1\nfi\n"
              name: Install Node.js
          - run:
              command: |
                if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

                # FUNCTIONS
                get_npm_version () {
                  if [[ latest == latest ]]; then
                    VERSION="$(npm view npm | sed -E 's|.*-||g' | grep latest | \
                      perl -pe 's/.*: //g' | perl -pe "s/'|,//g")"

                    echo "Latest version of NPM is $VERSION"
                  else
                    VERSION=latest

                    echo "Selected version of NPM is $VERSION"
                  fi
                }

                installation_check () {
                  if command -v npm > /dev/null 2>&1; then
                    if npm -v | grep "$VERSION" > /dev/null 2>&1; then
                      echo "NPM $VERSION is already installed"
                      exit 0
                    fi
                  fi
                }

                if cat /etc/issue 2> /dev/null | grep Alpine > /dev/null 2>&1; then
                  # https://wiki.alpinelinux.org/wiki/Include:Upgrading_to_Edge
                  sed -i -e 's/v[[:digit:]]\.[[:digit:]]\+/edge/g' /etc/apk/repositories
                  apk upgrade --update-cache --available > /dev/null 2>&1

                  apk --no-cache add npm > /dev/null 2>&1

                  echo "Success! NPM $(npm -v) (Alpine APK) has been installed to $(which npm)"
                else
                  get_npm_version
                  installation_check

                  if [[ latest == latest ]]; then
                    $SUDO npm install -g npm@latest > /dev/null 2>&1 || \
                      npm install -g npm@latest > /dev/null 2>&1
                  else
                    $SUDO npm install -g "npm@$VERSION" > /dev/null 2>&1 || \
                      npm install -g "npm@$VERSION" > /dev/null 2>&1
                  fi

                  # test/verify version
                  if npm -v | grep "$VERSION" > /dev/null 2>&1; then
                    echo "Success! NPM $(npm -v) has been installed to $(which npm)"
                  else
                    echo "Something went wrong; the specified version of NPM could not be installed"
                    exit 1
                  fi
                fi
              name: Install NPM
          - run:
              command: |
                if [[ $EUID == 0 ]]; then export SUDO=""; else export SUDO="sudo"; fi

                # FUNCTIONS
                get_yarn_version () {
                  if [[ "" == "" ]]; then
                    VERSION=$(curl --silent --show-error \
                      --location --fail --retry 3 \
                      https://api.github.com/repos/yarnpkg/yarn/releases/latest | \
                      grep tag_name | cut -d '"' -f 4 | \
                      cut -d 'v' -f 2)

                    echo "Latest version of Yarn is $VERSION"
                  else
                    VERSION=

                    echo "Selected version of Yarn is $VERSION"
                  fi
                }

                installation_check () {
                  if command -v yarn > /dev/null 2>&1; then
                    if yarn --version | grep "$VERSION" > /dev/null 2>&1; then
                      echo "Yarn $VERSION is already installed"
                      exit 0
                    else
                      echo "A different version of Yarn is installed ($(yarn --version)); removing it"

                      if uname -a | grep Darwin > /dev/null 2>&1; then
                        brew uninstall yarn > /dev/null 2>&1
                      elif cat /etc/issue | grep Alpine > /dev/null 2>&1; then
                        apk del yarn > /dev/null 2>&1
                      elif cat /etc/issue | grep Debian > /dev/null 2>&1; then
                        $SUDO apt-get remove yarn > /dev/null 2>&1 && \
                          $SUDO apt-get purge yarn > /dev/null 2>&1
                      elif cat /etc/issue | grep Ubuntu > /dev/null 2>&1; then
                        $SUDO apt-get remove yarn > /dev/null 2>&1 && \
                          $SUDO apt-get purge yarn > /dev/null 2>&1
                      elif command -v yum > /dev/null 2>&1; then
                        yum remove yarn > /dev/null 2>&1
                      fi

                      $SUDO rm -rf "$HOME/.yarn" > /dev/null 2>&1
                      $SUDO rm -f /usr/local/bin/yarn /usr/local/bin/yarnpkg > /dev/null 2>&1
                    fi
                  fi
                }

                get_yarn_version
                installation_check

                # install yarn
                curl -L -o yarn.tar.gz "https://yarnpkg.com/downloads/$VERSION/yarn-v$VERSION.tar.gz"

                $SUDO tar -xzf yarn.tar.gz && rm yarn.tar.gz

                $SUDO mkdir -p /opt/yarn

                $SUDO mv yarn-v${VERSION}/* /opt/yarn

                $SUDO rm -rf "yarn-v${VERSION}"

                $SUDO chmod 777 "/opt/yarn"

                $SUDO ln -s /opt/yarn/bin/yarn /usr/local/bin/yarn
                $SUDO ln -s /opt/yarn/bin/yarnpkg /usr/local/bin/yarnpkg
                $SUDO ln -s /opt/yarn/bin/yarn.js /usr/local/bin/yarn.js

                command -v yarn

                if uname -a | grep Darwin > /dev/null 2>&1; then
                  mkdir -p ~/.config
                  $SUDO chown -R "$USER:$GROUP" ~/.config
                fi

                # test/verify version
                if yarn --version | grep "$VERSION" > /dev/null 2>&1; then
                  echo "Success! Yarn $(yarn --version) has been installed to $(which yarn)"
                else
                  echo "Something went wrong; the specified version of Yarn could not be installed"
                  exit 1
                fi
              name: Install Yarn
          - run:
              name: Calculate the difference
              command: |
                sudo apt-get install xmlstarlet
                sudo npm install --global junit-reports-combiner
                test `junit-reports-combiner --operator=except --test-case-key='concat(@classname,"#",@name,"=>",normalize-space())' --namespace='brakeman=https://brakemanscanner.org/' /tmp/analysis-results/Brakeman/HEAD-analysis-results.xml /tmp/analysis-results/Brakeman/BASE-analysis-results.xml | tee /tmp/test-results/Brakeman/DELTA-analysis-results.xml | xmlstarlet sel -t -m '//failure|//error'  -v '.' -n | wc -l` -eq 0
          - store_test_results:
              path: /tmp/test-results
      workflows:
        analyze-code-statically:
          jobs:
          - dscar/execute
        version: 2
